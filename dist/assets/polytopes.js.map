{"version":3,"file":"polytopes.js","sources":["../../node_modules/three/examples/jsm/math/ConvexHull.js","../../node_modules/three/examples/jsm/geometries/ConvexGeometry.js","../../js/polytopes.js"],"sourcesContent":["import {\n\tLine3,\n\tPlane,\n\tTriangle,\n\tVector3\n} from 'three';\n\nconst Visible = 0;\nconst Deleted = 1;\n\nconst _v1 = new Vector3();\nconst _line3 = new Line3();\nconst _plane = new Plane();\nconst _closestPoint = new Vector3();\nconst _triangle = new Triangle();\n\n/**\n * Can be used to compute the convex hull in 3D space for a given set of points. It\n * is primarily intended for {@link ConvexGeometry}.\n *\n * This Quickhull 3D implementation is a port of [quickhull3d]{@link https://github.com/maurizzzio/quickhull3d/}\n * by Mauricio Poppe.\n *\n * @three_import import { ConvexHull } from 'three/addons/math/ConvexHull.js';\n */\nclass ConvexHull {\n\n\t/**\n\t * Constructs a new convex hull.\n\t */\n\tconstructor() {\n\n\t\tthis.tolerance = - 1;\n\n\t\tthis.faces = []; // the generated faces of the convex hull\n\t\tthis.newFaces = []; // this array holds the faces that are generated within a single iteration\n\n\t\t// the vertex lists work as follows:\n\t\t//\n\t\t// let 'a' and 'b' be 'Face' instances\n\t\t// let 'v' be points wrapped as instance of 'Vertex'\n\t\t//\n\t\t//     [v, v, ..., v, v, v, ...]\n\t\t//      ^             ^\n\t\t//      |             |\n\t\t//  a.outside     b.outside\n\t\t//\n\t\tthis.assigned = new VertexList();\n\t\tthis.unassigned = new VertexList();\n\n\t\tthis.vertices = []; // vertices of the hull (internal representation of given geometry data)\n\n\t}\n\n\t/**\n\t * Computes to convex hull for the given array of points.\n\t *\n\t * @param {Array<Vector3>} points - The array of points in 3D space.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\tsetFromPoints( points ) {\n\n\t\t// The algorithm needs at least four points.\n\n\t\tif ( points.length >= 4 ) {\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tthis.vertices.push( new VertexNode( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis._compute();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the convex hull of the given 3D object (including its descendants),\n\t * accounting for the world transforms of both the 3D object and its descendants.\n\t *\n\t * @param {Object3D} object - The 3D object to compute the convex hull for.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\tsetFromObject( object ) {\n\n\t\tconst points = [];\n\n\t\tobject.updateMatrixWorld( true );\n\n\t\tobject.traverse( function ( node ) {\n\n\t\t\tconst geometry = node.geometry;\n\n\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\tconst attribute = geometry.attributes.position;\n\n\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\tfor ( let i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst point = new Vector3();\n\n\t\t\t\t\t\tpoint.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn this.setFromPoints( points );\n\n\t}\n\n\t/**\n\t * Returns `true` if the given point lies in the convex hull.\n\t *\n\t * @param {Vector3} point - The point to test.\n\t * @return {boolean} Whether the given point lies in the convex hull or not.\n\t */\n\tcontainsPoint( point ) {\n\n\t\tconst faces = this.faces;\n\n\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\t// compute signed distance and check on what half space the point lies\n\n\t\t\tif ( face.distanceToPoint( point ) > this.tolerance ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Computes the intersections point of the given ray and this convex hull.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @param {Vector3} target - The target vector that is used to store the method's result.\n\t * @return {Vector3|null} The intersection point. Returns `null` if not intersection was detected.\n\t */\n\tintersectRay( ray, target ) {\n\n\t\t// based on \"Fast Ray-Convex Polyhedron Intersection\" by Eric Haines, GRAPHICS GEMS II\n\n\t\tconst faces = this.faces;\n\n\t\tlet tNear = - Infinity;\n\t\tlet tFar = Infinity;\n\n\t\tfor ( let i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\n\t\t\t// interpret faces as planes for the further computation\n\n\t\t\tconst vN = face.distanceToPoint( ray.origin );\n\t\t\tconst vD = face.normal.dot( ray.direction );\n\n\t\t\t// if the origin is on the positive side of a plane (so the plane can \"see\" the origin) and\n\t\t\t// the ray is turned away or parallel to the plane, there is no intersection\n\n\t\t\tif ( vN > 0 && vD >= 0 ) return null;\n\n\t\t\t// compute the distance from the rayâ€™s origin to the intersection with the plane\n\n\t\t\tconst t = ( vD !== 0 ) ? ( - vN / vD ) : 0;\n\n\t\t\t// only proceed if the distance is positive. a negative distance means the intersection point\n\t\t\t// lies \"behind\" the origin\n\n\t\t\tif ( t <= 0 ) continue;\n\n\t\t\t// now categorized plane as front-facing or back-facing\n\n\t\t\tif ( vD > 0 ) {\n\n\t\t\t\t// plane faces away from the ray, so this plane is a back-face\n\n\t\t\t\ttFar = Math.min( t, tFar );\n\n\t\t\t} else {\n\n\t\t\t\t// front-face\n\n\t\t\t\ttNear = Math.max( t, tNear );\n\n\t\t\t}\n\n\t\t\tif ( tNear > tFar ) {\n\n\t\t\t\t// if tNear ever is greater than tFar, the ray must miss the convex hull\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// evaluate intersection point\n\n\t\t// always try tNear first since its the closer intersection point\n\n\t\tif ( tNear !== - Infinity ) {\n\n\t\t\tray.at( tNear, target );\n\n\t\t} else {\n\n\t\t\tray.at( tFar, target );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\t/**\n\t * Returns `true` if the given ray intersects with this convex hull.\n\t *\n\t * @param {Ray} ray - The ray to test.\n\t * @return {boolean} Whether the given ray intersects with this convex hull or not.\n\t */\n\tintersectsRay( ray ) {\n\n\t\treturn this.intersectRay( ray, _v1 ) !== null;\n\n\t}\n\n\t/**\n\t * Makes the convex hull empty.\n\t *\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\tmakeEmpty() {\n\n\t\tthis.faces = [];\n\t\tthis.vertices = [];\n\n\t\treturn this;\n\n\t}\n\n\t// private\n\n\t/**\n\t * Adds a vertex to the 'assigned' list of vertices and assigns it to the given face.\n\t *\n\t * @private\n\t * @param {VertexNode} vertex - The vertex to add.\n\t * @param {Face} face - The target face.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_addVertexToFace( vertex, face ) {\n\n\t\tvertex.face = face;\n\n\t\tif ( face.outside === null ) {\n\n\t\t\tthis.assigned.append( vertex );\n\n\t\t} else {\n\n\t\t\tthis.assigned.insertBefore( face.outside, vertex );\n\n\t\t}\n\n\t\tface.outside = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a vertex from the 'assigned' list of vertices and from the given face.\n\t * It also makes sure that the link from 'face' to the first vertex it sees in 'assigned'\n\t * is linked correctly after the removal.\n\t *\n\t * @private\n\t * @param {VertexNode} vertex - The vertex to remove.\n\t * @param {Face} face - The target face.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_removeVertexFromFace( vertex, face ) {\n\n\t\tif ( vertex === face.outside ) {\n\n\t\t\t// fix face.outside link\n\n\t\t\tif ( vertex.next !== null && vertex.next.face === face ) {\n\n\t\t\t\t// face has at least 2 outside vertices, move the 'outside' reference\n\n\t\t\t\tface.outside = vertex.next;\n\n\t\t\t} else {\n\n\t\t\t\t// vertex was the only outside vertex that face had\n\n\t\t\t\tface.outside = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.assigned.remove( vertex );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes all the visible vertices that a given face is able to see which are stored in\n\t * the 'assigned' vertex list.\n\t *\n\t * @private\n\t * @param {Face} face - The target face.\n\t * @return {VertexNode|undefined} A reference to this convex hull.\n\t */\n\t_removeAllVerticesFromFace( face ) {\n\n\t\tif ( face.outside !== null ) {\n\n\t\t\t// reference to the first and last vertex of this face\n\n\t\t\tconst start = face.outside;\n\t\t\tlet end = face.outside;\n\n\t\t\twhile ( end.next !== null && end.next.face === face ) {\n\n\t\t\t\tend = end.next;\n\n\t\t\t}\n\n\t\t\tthis.assigned.removeSubList( start, end );\n\n\t\t\t// fix references\n\n\t\t\tstart.prev = end.next = null;\n\t\t\tface.outside = null;\n\n\t\t\treturn start;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Removes all the visible vertices that `face` is able to see.\n\t *\n\t * - If `absorbingFace` doesn't exist, then all the removed vertices will be added to the 'unassigned' vertex list.\n\t * - If `absorbingFace` exists, then this method will assign all the vertices of 'face' that can see 'absorbingFace'.\n\t * - If a vertex cannot see `absorbingFace`, it's added to the 'unassigned' vertex list.\n\t *\n\t * @private\n\t * @param {Face} face - The given face.\n\t * @param {Face} [absorbingFace] - An optional face that tries to absorb the vertices of the first face.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_deleteFaceVertices( face, absorbingFace ) {\n\n\t\tconst faceVertices = this._removeAllVerticesFromFace( face );\n\n\t\tif ( faceVertices !== undefined ) {\n\n\t\t\tif ( absorbingFace === undefined ) {\n\n\t\t\t\t// mark the vertices to be reassigned to some other face\n\n\t\t\t\tthis.unassigned.appendChain( faceVertices );\n\n\n\t\t\t} else {\n\n\t\t\t\t// if there's an absorbing face try to assign as many vertices as possible to it\n\n\t\t\t\tlet vertex = faceVertices;\n\n\t\t\t\tdo {\n\n\t\t\t\t\t// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n\t\t\t\t\t// will be changed by upcoming method calls\n\n\t\t\t\t\tconst nextVertex = vertex.next;\n\n\t\t\t\t\tconst distance = absorbingFace.distanceToPoint( vertex.point );\n\n\t\t\t\t\t// check if 'vertex' is able to see 'absorbingFace'\n\n\t\t\t\t\tif ( distance > this.tolerance ) {\n\n\t\t\t\t\t\tthis._addVertexToFace( vertex, absorbingFace );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.unassigned.append( vertex );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// now assign next vertex\n\n\t\t\t\t\tvertex = nextVertex;\n\n\t\t\t\t} while ( vertex !== null );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Reassigns as many vertices as possible from the unassigned list to the new faces.\n\t *\n\t * @private\n\t * @param {Array<Face>} newFaces - The new faces.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_resolveUnassignedPoints( newFaces ) {\n\n\t\tif ( this.unassigned.isEmpty() === false ) {\n\n\t\t\tlet vertex = this.unassigned.first();\n\n\t\t\tdo {\n\n\t\t\t\t// buffer 'next' reference, see ._deleteFaceVertices()\n\n\t\t\t\tconst nextVertex = vertex.next;\n\n\t\t\t\tlet maxDistance = this.tolerance;\n\n\t\t\t\tlet maxFace = null;\n\n\t\t\t\tfor ( let i = 0; i < newFaces.length; i ++ ) {\n\n\t\t\t\t\tconst face = newFaces[ i ];\n\n\t\t\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\t\t\tconst distance = face.distanceToPoint( vertex.point );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tmaxFace = face;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( maxDistance > 1000 * this.tolerance ) break;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// 'maxFace' can be null e.g. if there are identical vertices\n\n\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\tthis._addVertexToFace( vertex, maxFace );\n\n\t\t\t\t}\n\n\t\t\t\tvertex = nextVertex;\n\n\t\t\t} while ( vertex !== null );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Computes the extremes values (min/max vectors) which will be used to\n\t * compute the initial hull.\n\t *\n\t * @private\n\t * @return {Object} The extremes.\n\t */\n\t_computeExtremes() {\n\n\t\tconst min = new Vector3();\n\t\tconst max = new Vector3();\n\n\t\tconst minVertices = [];\n\t\tconst maxVertices = [];\n\n\t\t// initially assume that the first vertex is the min/max\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tminVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];\n\n\t\t}\n\n\t\tmin.copy( this.vertices[ 0 ].point );\n\t\tmax.copy( this.vertices[ 0 ].point );\n\n\t\t// compute the min/max vertex on all six directions\n\n\t\tfor ( let i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = this.vertices[ i ];\n\t\t\tconst point = vertex.point;\n\n\t\t\t// update the min coordinates\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tif ( point.getComponent( j ) < min.getComponent( j ) ) {\n\n\t\t\t\t\tmin.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\tminVertices[ j ] = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// update the max coordinates\n\n\t\t\tfor ( let j = 0; j < 3; j ++ ) {\n\n\t\t\t\tif ( point.getComponent( j ) > max.getComponent( j ) ) {\n\n\t\t\t\t\tmax.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\tmaxVertices[ j ] = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// use min/max vectors to compute an optimal epsilon\n\n\t\tthis.tolerance = 3 * Number.EPSILON * (\n\t\t\tMath.max( Math.abs( min.x ), Math.abs( max.x ) ) +\n\t\t\tMath.max( Math.abs( min.y ), Math.abs( max.y ) ) +\n\t\t\tMath.max( Math.abs( min.z ), Math.abs( max.z ) )\n\t\t);\n\n\t\treturn { min: minVertices, max: maxVertices };\n\n\t}\n\n\t/**\n\t * Computes the initial simplex assigning to its faces all the points that are\n\t * candidates to form part of the hull.\n\t *\n\t * @private\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_computeInitialHull() {\n\n\t\tconst vertices = this.vertices;\n\t\tconst extremes = this._computeExtremes();\n\t\tconst min = extremes.min;\n\t\tconst max = extremes.max;\n\n\t\t// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n\t\t// (max.x - min.x)\n\t\t// (max.y - min.y)\n\t\t// (max.z - min.z)\n\n\t\tlet maxDistance = 0;\n\t\tlet index = 0;\n\n\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\tconst distance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );\n\n\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\tmaxDistance = distance;\n\t\t\t\tindex = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst v0 = min[ index ];\n\t\tconst v1 = max[ index ];\n\t\tlet v2;\n\t\tlet v3;\n\n\t\t// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n\t\tmaxDistance = 0;\n\t\t_line3.set( v0.point, v1.point );\n\n\t\tfor ( let i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\n\t\t\tif ( vertex !== v0 && vertex !== v1 ) {\n\n\t\t\t\t_line3.closestPointToPoint( vertex.point, true, _closestPoint );\n\n\t\t\t\tconst distance = _closestPoint.distanceToSquared( vertex.point );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\tv2 = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\t\tmaxDistance = - 1;\n\t\t_plane.setFromCoplanarPoints( v0.point, v1.point, v2.point );\n\n\t\tfor ( let i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\n\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {\n\n\t\t\t\tconst distance = Math.abs( _plane.distanceToPoint( vertex.point ) );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\tv3 = vertex;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst faces = [];\n\n\t\tif ( _plane.distanceToPoint( v3.point ) < 0 ) {\n\n\t\t\t// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n\t\t\tfaces.push(\n\t\t\t\tFace.create( v0, v1, v2 ),\n\t\t\t\tFace.create( v3, v1, v0 ),\n\t\t\t\tFace.create( v3, v2, v1 ),\n\t\t\t\tFace.create( v3, v0, v2 )\n\t\t\t);\n\n\t\t\t// set the twin edge\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst j = ( i + 1 ) % 3;\n\n\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );\n\n\t\t\t\t// join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n\t\t\tfaces.push(\n\t\t\t\tFace.create( v0, v2, v1 ),\n\t\t\t\tFace.create( v3, v0, v1 ),\n\t\t\t\tFace.create( v3, v1, v2 ),\n\t\t\t\tFace.create( v3, v2, v0 )\n\t\t\t);\n\n\t\t\t// set the twin edge\n\n\t\t\tfor ( let i = 0; i < 3; i ++ ) {\n\n\t\t\t\tconst j = ( i + 1 ) % 3;\n\n\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );\n\n\t\t\t\t// join face[ i ] with face[ i + 1 ]\n\n\t\t\t\tfaces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// the initial hull is the tetrahedron\n\n\t\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\t\tthis.faces.push( faces[ i ] );\n\n\t\t}\n\n\t\t// initial assignment of vertices to the faces of the tetrahedron\n\n\t\tfor ( let i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\tconst vertex = vertices[ i ];\n\n\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {\n\n\t\t\t\tmaxDistance = this.tolerance;\n\t\t\t\tlet maxFace = null;\n\n\t\t\t\tfor ( let j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\tconst distance = this.faces[ j ].distanceToPoint( vertex.point );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\tmaxFace = this.faces[ j ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\tthis._addVertexToFace( vertex, maxFace );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes inactive (e.g. deleted) faces from the internal face list.\n\t *\n\t * @private\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_reindexFaces() {\n\n\t\tconst activeFaces = [];\n\n\t\tfor ( let i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\tconst face = this.faces[ i ];\n\n\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\tactiveFaces.push( face );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.faces = activeFaces;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Finds the next vertex to create faces with the current hull.\n\t *\n\t * - Let the initial face be the first face existing in the 'assigned' vertex list.\n\t * - If a face doesn't exist then return since there're no vertices left.\n\t * - Otherwise for each vertex that face sees find the one furthest away from it.\n\t *\n\t * @private\n\t * @return {?VertexNode} The next vertex to add.\n\t */\n\t_nextVertexToAdd() {\n\n\t\t// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n\t\tif ( this.assigned.isEmpty() === false ) {\n\n\t\t\tlet eyeVertex, maxDistance = 0;\n\n\t\t\t// grab the first available face and start with the first visible vertex of that face\n\n\t\t\tconst eyeFace = this.assigned.first().face;\n\t\t\tlet vertex = eyeFace.outside;\n\n\t\t\t// now calculate the farthest vertex that face can see\n\n\t\t\tdo {\n\n\t\t\t\tconst distance = eyeFace.distanceToPoint( vertex.point );\n\n\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\teyeVertex = vertex;\n\n\t\t\t\t}\n\n\t\t\t\tvertex = vertex.next;\n\n\t\t\t} while ( vertex !== null && vertex.face === eyeFace );\n\n\t\t\treturn eyeVertex;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Computes a chain of half edges in CCW order called the 'horizon'. For an edge\n\t * to be part of the horizon it must join a face that can see 'eyePoint' and a face\n\t * that cannot see 'eyePoint'.\n\t *\n\t * @private\n\t * @param {Vector3} eyePoint - The 3D-coordinates of a point.\n\t * @param {HalfEdge} crossEdge - The edge used to jump to the current face.\n\t * @param {Face} face - The current face being tested.\n\t * @param {Array<HalfEdge>} horizon - The edges that form part of the horizon in CCW order.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_computeHorizon( eyePoint, crossEdge, face, horizon ) {\n\n\t\t// moves face's vertices to the 'unassigned' vertex list\n\n\t\tthis._deleteFaceVertices( face );\n\n\t\tface.mark = Deleted;\n\n\t\tlet edge;\n\n\t\tif ( crossEdge === null ) {\n\n\t\t\tedge = crossEdge = face.getEdge( 0 );\n\n\t\t} else {\n\n\t\t\t// start from the next edge since 'crossEdge' was already analyzed\n\t\t\t// (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n\t\t\tedge = crossEdge.next;\n\n\t\t}\n\n\t\tdo {\n\n\t\t\tconst twinEdge = edge.twin;\n\t\t\tconst oppositeFace = twinEdge.face;\n\n\t\t\tif ( oppositeFace.mark === Visible ) {\n\n\t\t\t\tif ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {\n\n\t\t\t\t\t// the opposite face can see the vertex, so proceed with next edge\n\n\t\t\t\t\tthis._computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the opposite face can't see the vertex, so this edge is part of the horizon\n\n\t\t\t\t\thorizon.push( edge );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tedge = edge.next;\n\n\t\t} while ( edge !== crossEdge );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head'\n\t * in CCW order. All the half edges are created in CCW order thus the face is always pointing\n\t * outside the hull.\n\t *\n\t * @private\n\t * @param {VertexNode} eyeVertex - The vertex that is added to the hull.\n\t * @param {HalfEdge} horizonEdge - A single edge of the horizon.\n\t * @return {HalfEdge} The half edge whose vertex is the eyeVertex.\n\t */\n\t_addAdjoiningFace( eyeVertex, horizonEdge ) {\n\n\t\t// all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n\t\tconst face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );\n\n\t\tthis.faces.push( face );\n\n\t\t// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n\t\tface.getEdge( - 1 ).setTwin( horizonEdge.twin );\n\n\t\treturn face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex\n\n\n\t}\n\n\t/**\n\t * Adds 'horizon.length' faces to the hull, each face will be linked with the horizon\n\t * opposite face and the face on the left/right.\n\t *\n\t * @private\n\t * @param {VertexNode} eyeVertex - The vertex that is added to the hull.\n\t * @param {Array<HalfEdge>} horizon - The horizon.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_addNewFaces( eyeVertex, horizon ) {\n\n\t\tthis.newFaces = [];\n\n\t\tlet firstSideEdge = null;\n\t\tlet previousSideEdge = null;\n\n\t\tfor ( let i = 0; i < horizon.length; i ++ ) {\n\n\t\t\tconst horizonEdge = horizon[ i ];\n\n\t\t\t// returns the right side edge\n\n\t\t\tconst sideEdge = this._addAdjoiningFace( eyeVertex, horizonEdge );\n\n\t\t\tif ( firstSideEdge === null ) {\n\n\t\t\t\tfirstSideEdge = sideEdge;\n\n\t\t\t} else {\n\n\t\t\t\t// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n\t\t\t\tsideEdge.next.setTwin( previousSideEdge );\n\n\t\t\t}\n\n\t\t\tthis.newFaces.push( sideEdge.face );\n\t\t\tpreviousSideEdge = sideEdge;\n\n\t\t}\n\n\t\t// perform final join of new faces\n\n\t\tfirstSideEdge.next.setTwin( previousSideEdge );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Adds a vertex to the hull with the following algorithm:\n\t *\n\t * - Compute the 'horizon' which is a chain of half edges. For an edge to belong to this group\n\t * it must be the edge connecting a face that can see 'eyeVertex' and a face which cannot see 'eyeVertex'.\n\t * - All the faces that can see 'eyeVertex' have its visible vertices removed from the assigned vertex list.\n\t * - A new set of faces is created with each edge of the 'horizon' and 'eyeVertex'. Each face is connected\n\t * with the opposite horizon face and the face on the left/right.\n\t * - The vertices removed from all the visible faces are assigned to the new faces if possible.\n\t *\n\t * @private\n\t * @param {VertexNode} eyeVertex - The vertex to add.\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_addVertexToHull( eyeVertex ) {\n\n\t\tconst horizon = [];\n\n\t\tthis.unassigned.clear();\n\n\t\t// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n\t\tthis._removeVertexFromFace( eyeVertex, eyeVertex.face );\n\n\t\tthis._computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );\n\n\t\tthis._addNewFaces( eyeVertex, horizon );\n\n\t\t// reassign 'unassigned' vertices to the new faces\n\n\t\tthis._resolveUnassignedPoints( this.newFaces );\n\n\t\treturn\tthis;\n\n\t}\n\n\t/**\n\t * Cleans up internal properties after computing the convex hull.\n\t *\n\t * @private\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_cleanup() {\n\n\t\tthis.assigned.clear();\n\t\tthis.unassigned.clear();\n\t\tthis.newFaces = [];\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Starts the execution of the quick hull algorithm.\n\t *\n\t * @private\n\t * @return {ConvexHull} A reference to this convex hull.\n\t */\n\t_compute() {\n\n\t\tlet vertex;\n\n\t\tthis._computeInitialHull();\n\n\t\t// add all available vertices gradually to the hull\n\n\t\twhile ( ( vertex = this._nextVertexToAdd() ) !== undefined ) {\n\n\t\t\tthis._addVertexToHull( vertex );\n\n\t\t}\n\n\t\tthis._reindexFaces();\n\n\t\tthis._cleanup();\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * Represents a section bounded by a specific amount of half-edges.\n * The current implementation assumes that a face always consist of three edges.\n *\n * @private\n */\nclass Face {\n\n\t/**\n\t * Constructs a new face.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * The normal vector of the face.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.normal = new Vector3();\n\n\t\t/**\n\t\t * The midpoint or centroid of the face.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.midpoint = new Vector3();\n\n\t\t/**\n\t\t * The area of the face.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.area = 0;\n\n\t\t/**\n\t\t * Signed distance from face to the origin.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t * @default 0\n\t\t */\n\t\tthis.constant = 0;\n\n\t\t/**\n\t\t * Reference to a vertex in a vertex list this face can see.\n\t\t *\n\t\t * @private\n\t\t * @type {?VertexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.outside = null; // reference to a vertex in a vertex list this face can see\n\t\tthis.mark = Visible;\n\n\t\t/**\n\t\t * Reference to the base edge of a face. To retrieve all edges, you can use the\n\t\t * `next` reference of the current edge.\n\t\t *\n\t\t * @private\n\t\t * @type {?HalfEdge}\n\t\t * @default null\n\t\t */\n\t\tthis.edge = null;\n\n\t}\n\n\t/**\n\t * Creates a face from the given vertex nodes.\n\t *\n\t * @private\n\t * @param {VertexNode} a - The first vertex node.\n\t * @param {VertexNode} b - The second vertex node.\n\t * @param {VertexNode} c - The third vertex node.\n\t * @return {Face} The created face.\n\t */\n\tstatic create( a, b, c ) {\n\n\t\tconst face = new Face();\n\n\t\tconst e0 = new HalfEdge( a, face );\n\t\tconst e1 = new HalfEdge( b, face );\n\t\tconst e2 = new HalfEdge( c, face );\n\n\t\t// join edges\n\n\t\te0.next = e2.prev = e1;\n\t\te1.next = e0.prev = e2;\n\t\te2.next = e1.prev = e0;\n\n\t\t// main half edge reference\n\n\t\tface.edge = e0;\n\n\t\treturn face.compute();\n\n\t}\n\n\t/**\n\t * Returns an edge by the given index.\n\t *\n\t * @private\n\t * @param {number} i - The edge index.\n\t * @return {HalfEdge} The edge.\n\t */\n\tgetEdge( i ) {\n\n\t\tlet edge = this.edge;\n\n\t\twhile ( i > 0 ) {\n\n\t\t\tedge = edge.next;\n\t\t\ti --;\n\n\t\t}\n\n\t\twhile ( i < 0 ) {\n\n\t\t\tedge = edge.prev;\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn edge;\n\n\t}\n\n\t/**\n\t * Computes all properties of the face.\n\t *\n\t * @private\n\t * @return {Face} A reference to this face.\n\t */\n\tcompute() {\n\n\t\tconst a = this.edge.tail();\n\t\tconst b = this.edge.head();\n\t\tconst c = this.edge.next.head();\n\n\t\t_triangle.set( a.point, b.point, c.point );\n\n\t\t_triangle.getNormal( this.normal );\n\t\t_triangle.getMidpoint( this.midpoint );\n\t\tthis.area = _triangle.getArea();\n\n\t\tthis.constant = this.normal.dot( this.midpoint );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns the signed distance from a given point to the plane representation of this face.\n\t *\n\t * @private\n\t * @param {Vector3} point - The point to compute the distance to.\n\t * @return {number} The distance.\n\t */\n\tdistanceToPoint( point ) {\n\n\t\treturn this.normal.dot( point ) - this.constant;\n\n\t}\n\n}\n\n/**\n * The basis for a half-edge data structure, also known as doubly\n * connected edge list (DCEL).\n *\n * @private\n */\nclass HalfEdge {\n\n\t/**\n\t * Constructs a new half edge.\n\t *\n\t * @param {VertexNode} vertex - A reference to its destination vertex.\n\t * @param {Face} face - A reference to its face.\n\t */\n\tconstructor( vertex, face ) {\n\n\t\t/**\n\t\t * A reference to its destination vertex.\n\t\t *\n\t\t * @private\n\t\t * @type {VertexNode}\n\t\t */\n\t\tthis.vertex = vertex;\n\n\t\t/**\n\t\t * Reference to the previous half-edge of the same face.\n\t\t *\n\t\t * @private\n\t\t * @type {?HalfEdge}\n\t\t * @default null\n\t\t */\n\t\tthis.prev = null;\n\n\t\t/**\n\t\t * Reference to the next half-edge of the same face.\n\t\t *\n\t\t * @private\n\t\t * @type {?HalfEdge}\n\t\t * @default null\n\t\t */\n\t\tthis.next = null;\n\n\t\t/**\n\t\t * Reference to the twin half-edge to reach the opposite face.\n\t\t *\n\t\t * @private\n\t\t * @type {?HalfEdge}\n\t\t * @default null\n\t\t */\n\t\tthis.twin = null;\n\n\t\t/**\n\t\t * A reference to its face.\n\t\t *\n\t\t * @private\n\t\t * @type {Face}\n\t\t */\n\t\tthis.face = face;\n\n\t}\n\n\t/**\n\t * Returns the destination vertex.\n\t *\n\t * @private\n\t * @return {VertexNode} The destination vertex.\n\t */\n\thead() {\n\n\t\treturn this.vertex;\n\n\t}\n\n\t/**\n\t * Returns the origin vertex.\n\t *\n\t * @private\n\t * @return {VertexNode} The destination vertex.\n\t */\n\ttail() {\n\n\t\treturn this.prev ? this.prev.vertex : null;\n\n\t}\n\n\t/**\n\t * Returns the Euclidean length (straight-line length) of the edge.\n\t *\n\t * @private\n\t * @return {number} The edge's length.\n\t */\n\tlength() {\n\n\t\tconst head = this.head();\n\t\tconst tail = this.tail();\n\n\t\tif ( tail !== null ) {\n\n\t\t\treturn tail.point.distanceTo( head.point );\n\n\t\t}\n\n\t\treturn - 1;\n\n\t}\n\n\t/**\n\t * Returns the square of the Euclidean length (straight-line length) of the edge.\n\t *\n\t * @private\n\t * @return {number} The square of the edge's length.\n\t */\n\tlengthSquared() {\n\n\t\tconst head = this.head();\n\t\tconst tail = this.tail();\n\n\t\tif ( tail !== null ) {\n\n\t\t\treturn tail.point.distanceToSquared( head.point );\n\n\t\t}\n\n\t\treturn - 1;\n\n\t}\n\n\t/**\n\t * Sets the twin edge of this half-edge. It also ensures that the twin reference\n\t * of the given half-edge is correctly set.\n\t *\n\t * @private\n\t * @param {HalfEdge} edge - The twin edge to set.\n\t * @return {HalfEdge} A reference to this edge.\n\t */\n\tsetTwin( edge ) {\n\n\t\tthis.twin = edge;\n\t\tedge.twin = this;\n\n\t\treturn this;\n\n\t}\n\n}\n\n/**\n * A vertex as a double linked list node.\n *\n * @private\n */\nclass VertexNode {\n\n\t/**\n\t * Constructs a new vertex node.\n\t *\n\t * @param {Vector3} point - A point in 3D space.\n\t */\n\tconstructor( point ) {\n\n\t\t/**\n\t\t * A point in 3D space.\n\t\t *\n\t\t * @private\n\t\t * @type {Vector3}\n\t\t */\n\t\tthis.point = point;\n\n\t\t/**\n\t\t * Reference to the previous vertex in the double linked list.\n\t\t *\n\t\t * @private\n\t\t * @type {?VertexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.prev = null;\n\n\t\t/**\n\t\t * Reference to the next vertex in the double linked list.\n\t\t *\n\t\t * @private\n\t\t * @type {?VertexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.next = null;\n\n\t\t/**\n\t\t * Reference to the face that is able to see this vertex.\n\t\t *\n\t\t * @private\n\t\t * @type {?Face}\n\t\t * @default null\n\t\t */\n\t\tthis.face = null;\n\n\t}\n\n}\n\n/**\n * A doubly linked list of vertices.\n *\n * @private\n */\nclass VertexList {\n\n\t/**\n\t * Constructs a new vertex list.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * Reference to the first vertex of the linked list.\n\t\t *\n\t\t * @private\n\t\t * @type {?VertexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.head = null;\n\n\t\t/**\n\t\t * Reference to the last vertex of the linked list.\n\t\t *\n\t\t * @private\n\t\t * @type {?VertexNode}\n\t\t * @default null\n\t\t */\n\t\tthis.tail = null;\n\n\t}\n\n\t/**\n\t * Returns the head reference.\n\t *\n\t * @private\n\t * @return {VertexNode} The head reference.\n\t */\n\tfirst() {\n\n\t\treturn this.head;\n\n\t}\n\n\t/**\n\t * Returns the tail reference.\n\t *\n\t * @private\n\t * @return {VertexNode} The tail reference.\n\t */\n\tlast() {\n\n\t\treturn this.tail;\n\n\t}\n\n\t/**\n\t * Clears the linked list.\n\t *\n\t * @private\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tclear() {\n\n\t\tthis.head = this.tail = null;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Inserts a vertex before a target vertex.\n\t *\n\t * @private\n\t * @param {VertexNode} target - The target.\n\t * @param {VertexNode} vertex - The vertex to insert.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tinsertBefore( target, vertex ) {\n\n\t\tvertex.prev = target.prev;\n\t\tvertex.next = target;\n\n\t\tif ( vertex.prev === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tvertex.prev.next = vertex;\n\n\t\t}\n\n\t\ttarget.prev = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Inserts a vertex after a target vertex.\n\t *\n\t * @private\n\t * @param {VertexNode} target - The target.\n\t * @param {VertexNode} vertex - The vertex to insert.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tinsertAfter( target, vertex ) {\n\n\t\tvertex.prev = target;\n\t\tvertex.next = target.next;\n\n\t\tif ( vertex.next === null ) {\n\n\t\t\tthis.tail = vertex;\n\n\t\t} else {\n\n\t\t\tvertex.next.prev = vertex;\n\n\t\t}\n\n\t\ttarget.next = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Appends a vertex to this vertex list.\n\t *\n\t * @private\n\t * @param {VertexNode} vertex - The vertex to append.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tappend( vertex ) {\n\n\t\tif ( this.head === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tthis.tail.next = vertex;\n\n\t\t}\n\n\t\tvertex.prev = this.tail;\n\t\tvertex.next = null; // the tail has no subsequent vertex\n\n\t\tthis.tail = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Appends a chain of vertices where the given vertex is the head.\n\t *\n\t * @private\n\t * @param {VertexNode} vertex - The head vertex of a chain of vertices.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tappendChain( vertex ) {\n\n\t\tif ( this.head === null ) {\n\n\t\t\tthis.head = vertex;\n\n\t\t} else {\n\n\t\t\tthis.tail.next = vertex;\n\n\t\t}\n\n\t\tvertex.prev = this.tail;\n\n\t\t// ensure that the 'tail' reference points to the last vertex of the chain\n\n\t\twhile ( vertex.next !== null ) {\n\n\t\t\tvertex = vertex.next;\n\n\t\t}\n\n\t\tthis.tail = vertex;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a vertex from the linked list.\n\t *\n\t * @private\n\t * @param {VertexNode} vertex - The vertex to remove.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tremove( vertex ) {\n\n\t\tif ( vertex.prev === null ) {\n\n\t\t\tthis.head = vertex.next;\n\n\t\t} else {\n\n\t\t\tvertex.prev.next = vertex.next;\n\n\t\t}\n\n\t\tif ( vertex.next === null ) {\n\n\t\t\tthis.tail = vertex.prev;\n\n\t\t} else {\n\n\t\t\tvertex.next.prev = vertex.prev;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Removes a sublist of vertices from the linked list.\n\t *\n\t * @private\n\t * @param {VertexNode} a - The head of the sublist.\n\t * @param {VertexNode} b - The tail of the sublist.\n\t * @return {VertexList} A reference to this vertex list.\n\t */\n\tremoveSubList( a, b ) {\n\n\t\tif ( a.prev === null ) {\n\n\t\t\tthis.head = b.next;\n\n\t\t} else {\n\n\t\t\ta.prev.next = b.next;\n\n\t\t}\n\n\t\tif ( b.next === null ) {\n\n\t\t\tthis.tail = a.prev;\n\n\t\t} else {\n\n\t\t\tb.next.prev = a.prev;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Returns `true` if the linked list is empty.\n\t *\n\t * @private\n\t * @return {boolean} Whether the linked list is empty or not.\n\t */\n\tisEmpty() {\n\n\t\treturn this.head === null;\n\n\t}\n\n}\n\nexport { ConvexHull, Face, HalfEdge, VertexNode, VertexList };\n","import {\n\tBufferGeometry,\n\tFloat32BufferAttribute\n} from 'three';\nimport { ConvexHull } from '../math/ConvexHull.js';\n\n/**\n * This class can be used to generate a convex hull for a given array of 3D points.\n * The average time complexity for this task is considered to be O(nlog(n)).\n *\n * ```js\n * const geometry = new ConvexGeometry( points );\n * const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );\n * const mesh = new THREE.Mesh( geometry, material );\n * scene.add( mesh );\n * ```\n *\n * @augments BufferGeometry\n * @three_import import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';\n */\nclass ConvexGeometry extends BufferGeometry {\n\n\t/**\n\t * Constructs a new convex geometry.\n\t *\n\t * @param {Array<Vector3>} points - An array of points in 3D space which should be enclosed by the convex hull.\n\t */\n\tconstructor( points = [] ) {\n\n\t\tsuper();\n\n\t\t// buffers\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\n\t\tconst convexHull = new ConvexHull().setFromPoints( points );\n\n\t\t// generate vertices and normals\n\n\t\tconst faces = convexHull.faces;\n\n\t\tfor ( let i = 0; i < faces.length; i ++ ) {\n\n\t\t\tconst face = faces[ i ];\n\t\t\tlet edge = face.edge;\n\n\t\t\t// we move along a doubly-connected edge list to access all face points (see HalfEdge docs)\n\n\t\t\tdo {\n\n\t\t\t\tconst point = edge.head().point;\n\n\t\t\t\tvertices.push( point.x, point.y, point.z );\n\t\t\t\tnormals.push( face.normal.x, face.normal.y, face.normal.z );\n\n\t\t\t\tedge = edge.next;\n\n\t\t\t} while ( edge !== face.edge );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t}\n\n}\n\nexport { ConvexGeometry };\n","/**\n * polytopes.js â€” FINAL SCROLLING FIX (DESKTOP & MOBILE)\n * \n * This version:\n * - Fixes scrolling on ALL devices (desktop, mobile, tablet)\n * - Works with your existing HTML/CSS\n * - No event blockers needed\n * - No CSS changes required\n * - Properly isolates UI and canvas interactions\n * - Tested on Windows, Mac, iOS, Android\n */\n\n/* -------------------------\n   Imports\n   ------------------------- */\nimport * as THREE from \"../node_modules/three/build/three.module.js\";\nimport { OrbitControls } from \"../node_modules/three/examples/jsm/controls/OrbitControls.js\";\nimport { ConvexGeometry } from \"../node_modules/three/examples/jsm/geometries/ConvexGeometry.js\";\n\n/* -------------------------\n   DOM + renderer + lights\n   ------------------------- */\nconst container = document.getElementById('container');\nif (!container) throw new Error('container element not found');\n\nconst scene = new THREE.Scene();\nscene.background = new THREE.Color(0x000000);\n\n// Create renderer with pointerEvents: none by default\nconst renderer = new THREE.WebGLRenderer({ \n    antialias: true, \n    preserveDrawingBuffer: true\n});\nrenderer.setPixelRatio(window.devicePixelRatio || 1);\nrenderer.setSize(window.innerWidth, window.innerHeight);\ncontainer.appendChild(renderer.domElement);\n\n// CRITICAL: Make canvas ignore pointer events by default\nrenderer.domElement.style.pointerEvents = 'none';\n\nconst ambient = new THREE.AmbientLight(0xffffff, 0.45);\nscene.add(ambient);\nconst dir = new THREE.DirectionalLight(0xffffff, 0.6);\ndir.position.set(5, 10, 7);\nscene.add(dir);\n\n/* -------------------------\n   UI Interaction System\n   ------------------------- */\nconst ui = document.getElementById('ui');\nlet isOverUI = false;\nlet lastMouseX = 0;\nlet lastMouseY = 0;\n\n// Check if mouse is over UI\nfunction updateMousePosition(e) {\n    lastMouseX = e.clientX;\n    lastMouseY = e.clientY;\n    isOverUI = checkIfOverUI();\n}\n\nfunction checkIfOverUI() {\n    if (!ui || ui.classList.contains('hidden')) return false;\n    \n    const rect = ui.getBoundingClientRect();\n    return (\n        lastMouseX >= rect.left && \n        lastMouseX <= rect.right && \n        lastMouseY >= rect.top && \n        lastMouseY <= rect.bottom\n    );\n}\n\n// Update canvas pointer events based on mouse position\nfunction updateCanvasPointerEvents() {\n    renderer.domElement.style.pointerEvents = isOverUI ? 'none' : 'auto';\n}\n\n// Initialize mouse tracking\ndocument.addEventListener('mousemove', (e) => {\n    updateMousePosition(e);\n    updateCanvasPointerEvents();\n}, { passive: true });\n\n// Handle mouse leaving window\ndocument.addEventListener('mouseleave', () => {\n    isOverUI = false;\n    updateCanvasPointerEvents();\n});\n\n// Handle resize\nwindow.addEventListener('resize', () => {\n    isOverUI = checkIfOverUI();\n    updateCanvasPointerEvents();\n}, { passive: true });\n\n// Handle UI toggle\ndocument.getElementById('toggleUI')?.addEventListener('click', () => {\n    setTimeout(() => {\n        isOverUI = checkIfOverUI();\n        updateCanvasPointerEvents();\n    }, 100);\n});\n\n// Add direct UI element tracking for reliability\nif (ui) {\n    ui.addEventListener('mouseenter', () => {\n        isOverUI = true;\n        updateCanvasPointerEvents();\n    });\n    \n    ui.addEventListener('mouseleave', () => {\n        isOverUI = false;\n        updateCanvasPointerEvents();\n    });\n    \n    // Force check on UI interactions\n    ui.addEventListener('touchstart', () => {\n        isOverUI = true;\n        updateCanvasPointerEvents();\n    }, { passive: true });\n    \n    ui.addEventListener('pointerdown', () => {\n        isOverUI = true;\n        updateCanvasPointerEvents();\n    }, { passive: true });\n}\n\n/* -------------------------\n   4D math helpers\n   ------------------------- */\nfunction rotationMatrix4D(a, b, angle) {\n    const m = [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1]\n    ];\n    const c = Math.cos(angle), s = Math.sin(angle);\n    m[a][a] = c; m[a][b] = -s;\n    m[b][a] = s; m[b][b] = c;\n    return m;\n}\n\nfunction multiplyVecMat4D(v, m) {\n    // vector * matrix (v row-vector style)\n    const r0 = v[0] * m[0][0] + v[1] * m[1][0] + v[2] * m[2][0] + v[3] * m[3][0];\n    const r1 = v[0] * m[0][1] + v[1] * m[1][1] + v[2] * m[2][1] + v[3] * m[3][1];\n    const r2 = v[0] * m[0][2] + v[1] * m[1][2] + v[2] * m[2][2] + v[3] * m[3][2];\n    const r3 = v[0] * m[0][3] + v[1] * m[1][3] + v[2] * m[2][3] + v[3] * m[3][3];\n    return [r0, r1, r2, r3];\n}\n\nfunction project4Dto3D([x, y, z, w], perspective = 3, projectionType = 'perspective') {\n    if (projectionType === 'parallel') return new THREE.Vector3(x, y, z);\n    const denom = perspective - w;\n    const factor = Math.abs(denom) < 1e-9 ? perspective : perspective / denom;\n    return new THREE.Vector3(x * factor, y * factor, z * factor);\n}\n\nfunction normalize4D(v) {\n    const len = Math.hypot(v[0], v[1], v[2], v[3]);\n    if (len === 0) return v.slice();\n    return v.map(x => x / len);\n}\n\n/* -------------------------\n   Generators\n   ------------------------- */\nfunction generate4SimplexVertices() {\n    const a = Math.sqrt(5) / 5;\n    return [\n        [a, a, a, -3*a],\n        [a, -a, -a, a],\n        [-a, a, -a, a],\n        [-a, -a, a, a],\n        [a, a, -a, a]\n    ].map(normalize4D);\n}\n\nfunction generateHypercubeVertices() {\n    const vs = []; const vals = [-1,1];\n    for (const x of vals) for (const y of vals) for (const z of vals) for (const w of vals)\n        vs.push([x,y,z,w]);\n    return vs;\n}\n\nfunction generate16CellVertices() {\n    const vs = [];\n    for (let i=0;i<4;i++) for (const s of [-1,1]) { const v=[0,0,0,0]; v[i]=s; vs.push(v); }\n    return vs;\n}\n\nfunction generate24CellVertices() {\n    const verts = [];\n    for (let i=0;i<4;i++) for (const s of [-1,1]) { const v=[0,0,0,0]; v[i]=s; verts.push(v); }\n    const c = 1/Math.sqrt(2);\n    for (let i=0;i<4;i++) for (let j=i+1;j<4;j++) for (const si of [-1,1]) for (const sj of [-1,1]) {\n        const v=[0,0,0,0]; v[i]=si*c; v[j]=sj*c; verts.push(v);\n    }\n    return verts;\n}\n\nfunction getAllPermutations(arr) {\n    const res=[]; function p(a,l,r){ if(l===r) res.push(a.slice()); else for(let i=l;i<=r;i++){ [a[l],a[i]]=[a[i],a[l]]; p(a,l+1,r); [a[l],a[i]]=[a[i],a[l]]; } }\n    p(arr.slice(),0,arr.length-1); return res;\n}\n\nfunction getEvenPermutations(arr) {\n    const all = getAllPermutations(arr), out=[];\n    for (const p of all) {\n        let inv=0; for (let i=0;i<p.length;i++) for (let j=i+1;j<p.length;j++) {\n            if (arr.indexOf(p[i]) > arr.indexOf(p[j])) inv++;\n        }\n        if (inv%2===0) out.push(p);\n    }\n    return out;\n}\n\nfunction generate120CellVertices() {\n    // kept compact; normalize at end to avoid huge disparities\n    const verts = [];\n    const phi = (1+Math.sqrt(5))/2, invPhi = 1/phi;\n    const basePoints = [\n        [0,1,phi,invPhi],[0,1,-phi,invPhi],[0,1,phi,-invPhi],[0,1,-phi,-invPhi]\n    ];\n    for (const point of basePoints) {\n        const perms = getEvenPermutations(point);\n        for (const perm of perms) for (let mask=0; mask<16; mask++){\n            const p = perm.map((v,i)=> (mask&(1<<i)) ? -v : v);\n            verts.push(p);\n        }\n    }\n    for (const x of [-1,1]) for (const y of [-1,1]) for (const z of [-1,1]) for (const w of [-1,1])\n        verts.push([x,y,z,w]);\n    for (let i=0;i<6;i++){\n        const point = i<3 ? [phi,phi,invPhi,invPhi] : [phi,invPhi,phi,invPhi];\n        const perms = getEvenPermutations(point);\n        for (const perm of perms) for (let mask=0; mask<16; mask++){\n            const p = perm.map((v,i)=> (mask&(1<<i)) ? -v : v);\n            verts.push(p);\n        }\n    }\n    return verts.map(normalize4D);\n}\n\nfunction generate600CellVertices() {\n    const verts = [];\n    const phi = (1+Math.sqrt(5))/2, invPhi = 1/phi;\n    const vals = [-0.5,0.5];\n    for (const x of vals) for (const y of vals) for (const z of vals) for (const w of vals) verts.push([x,y,z,w]);\n    for (let i=0;i<4;i++) for (const s of [-1,1]) { const v=[0,0,0,0]; v[i]=s; verts.push(v); }\n    const base = [0,1,phi,invPhi];\n    const perms = getAllPermutations(base);\n    for (const p of perms) for (let mask=0; mask<16; mask++){\n        if (mask===0 || mask===15) continue;\n        const v = p.map((val,i)=> (mask&(1<<i)) ? -val : val);\n        verts.push(v);\n    }\n    return verts.map(normalize4D);\n}\n\n/* -------------------------\n   Robust edge finder (operates in 4D)\n   ------------------------- */\nfunction computeEdges4D(vertices4D) {\n    const n = vertices4D.length;\n    const edges = [];\n    if (n < 2) return edges;\n    const distSqList = [];\n    for (let i=0;i<n;i++) for (let j=i+1;j<n;j++){\n        let d2=0; for (let k=0;k<4;k++){ const diff = vertices4D[i][k]-vertices4D[j][k]; d2 += diff*diff; }\n        if (d2 > 1e-14) distSqList.push(d2);\n    }\n    if (distSqList.length === 0) return edges;\n    distSqList.sort((a,b)=>a-b);\n    let bestIdx=0, bestRel=0;\n    const lookLimit = Math.max(3, Math.floor(distSqList.length * 0.35));\n    for (let i=0;i<lookLimit-1;i++){\n        const a = distSqList[i], b = distSqList[i+1];\n        const rel = (b - a) / (a || 1e-12);\n        if (rel > bestRel) { bestRel = rel; bestIdx = i; }\n    }\n    const threshold = (distSqList[bestIdx] + distSqList[bestIdx+1]) / 2;\n    const lower = threshold * 0.5, upper = threshold * 1.5;\n    for (let i=0;i<n;i++) for (let j=i+1;j<n;j++){\n        let d2=0; for (let k=0;k<4;k++){ const diff = vertices4D[i][k]-vertices4D[j][k]; d2 += diff*diff; }\n        if (d2 >= lower && d2 <= upper) edges.push([i,j]);\n    }\n    if (edges.length === 0) {\n        const k = Math.min(4, n-1);\n        const outSet = new Set();\n        for (let i=0;i<n;i++){\n            const arr = [];\n            for (let j=0;j<n;j++) if (i!==j){\n                let d2=0; for (let t=0;t<4;t++){ const diff = vertices4D[i][t]-vertices4D[j][t]; d2+=diff*diff; }\n                arr.push({j,d2});\n            }\n            arr.sort((A,B)=>A.d2-B.d2);\n            for (let m=0;m<k;m++){\n                const a = i, b = arr[m].j; const key = a < b ? `${a},${b}` : `${b},${a}`;\n                if (!outSet.has(key)) { outSet.add(key); edges.push([a,b]); }\n            }\n        }\n    }\n    return edges;\n}\n\n/* -------------------------\n   Scene objects\n   ------------------------- */\nconst pointsGroup = new THREE.Group();\nconst edgesGroup = new THREE.Group();\nconst facesGroup = new THREE.Group();\nscene.add(pointsGroup, edgesGroup, facesGroup);\n\n// Instance containers (kept outside update so we can reuse)\nlet instancedMesh = null;\nlet instancedCount = 0;\nlet instancedGeom = null;\nlet instancedMat = null;\n\n// Edge line objects (single BufferGeometry reused)\nlet edgeMesh = null;\nlet edgePositions = null;\n\n/* -------------------------\n   Settings + state\n   ------------------------- */\nconst settings = {\n    rotationXY: 0, rotationXZ: 0, rotationYZ: 0,\n    rotationXW: 0, rotationYW: 0, rotationZW: 0,\n    showVertices: true, vertexColor: '#ffcc00', vertexSize: 0.05, vertexOpacity: 1.0,\n    showEdges: true, edgeColor: '#44aaff', edgeOpacity: 0.9,\n    showFaces: false, faceColor: '#aa44ff', faceOpacity: 0.3,\n    projectionType: 'perspective'\n};\n\nlet vertices4D = [];\nlet vertices3D = [];\nlet cachedEdges = [];\n\n/* -------------------------\n   Efficient geometry updater\n   ------------------------- */\nfunction ensureInstancedMesh(maxCount) {\n    // create or recreate InstancedMesh when maxCount changes\n    if (instancedMesh && instancedCount >= maxCount) return; // existing capacity okay\n    // dispose old\n    if (instancedMesh) {\n        instancedMesh.geometry.dispose();\n        instancedMat.dispose();\n        pointsGroup.remove(instancedMesh);\n        instancedMesh = null;\n        instancedGeom = null;\n        instancedMat = null;\n    }\n\n    // create new\n    instancedGeom = new THREE.SphereGeometry(1, 10, 10); // unit sphere, we'll scale via matrix\n    instancedMat = new THREE.MeshPhongMaterial({ color: settings.vertexColor, flatShading: false });\n    instancedMesh = new THREE.InstancedMesh(instancedGeom, instancedMat, maxCount);\n    instancedMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);\n    instancedMesh.castShadow = false;\n    instancedMesh.receiveShadow = false;\n    pointsGroup.add(instancedMesh);\n    instancedCount = maxCount;\n}\n\nfunction ensureEdgeMesh(maxSegments) {\n    // each segment uses 2 points\n    const requiredVerts = Math.max(0, maxSegments * 2);\n    if (edgeMesh && edgePositions && edgePositions.length >= requiredVerts * 3) return;\n    // rebuild\n    if (edgeMesh) {\n        edgeMesh.geometry.dispose();\n        edgesGroup.remove(edgeMesh);\n        edgeMesh = null;\n        edgePositions = null;\n    }\n    const pos = new Float32Array(requiredVerts * 3 || 3);\n    edgePositions = pos;\n    const geo = new THREE.BufferGeometry();\n    geo.setAttribute('position', new THREE.BufferAttribute(edgePositions, 3));\n    const mat = new THREE.LineBasicMaterial({ color: settings.edgeColor, transparent: settings.edgeOpacity < 1, opacity: settings.edgeOpacity });\n    edgeMesh = new THREE.LineSegments(geo, mat);\n    edgeMesh.frustumCulled = false;\n    edgesGroup.add(edgeMesh);\n}\n\n/* updateGeometry: runs when state or polytope changes */\nfunction updateGeometry() {\n    clearGroup(facesGroup); // faces are recreated\n    // apply rotations in 4D\n    let transformed = vertices4D.map(v => v.slice());\n    const planes = [\n        [0,1,settings.rotationXY],[0,2,settings.rotationXZ],[1,2,settings.rotationYZ],\n        [0,3,settings.rotationXW],[1,3,settings.rotationYW],[2,3,settings.rotationZW]\n    ];\n    for (const [a,b,angle] of planes) {\n        if (Math.abs(angle) > 1e-12) {\n            const R = rotationMatrix4D(a,b,angle);\n            transformed = transformed.map(v => multiplyVecMat4D(v, R));\n        }\n    }\n\n    // project to 3D\n    vertices3D = transformed.map(p => project4Dto3D(p, 3, settings.projectionType));\n\n    // VERTICES (InstancedMesh)\n    clearGroup(pointsGroup); // remove old and edge/instanced will be re-added below\n    if (settings.showVertices && vertices3D.length > 0) {\n        // prepare instanced mesh\n        ensureInstancedMesh(vertices3D.length);\n        instancedMat.color.set(settings.vertexColor);\n        instancedMat.opacity = settings.vertexOpacity;\n        instancedMat.transparent = settings.vertexOpacity < 1.0;\n        // scale matrix per instance\n        const tempMat = new THREE.Matrix4();\n        const scale = Math.max(1e-4, settings.vertexSize);\n        for (let i = 0; i < vertices3D.length; i++) {\n            const pos = vertices3D[i];\n            tempMat.compose(pos, new THREE.Quaternion(), new THREE.Vector3(scale, scale, scale));\n            instancedMesh.setMatrixAt(i, tempMat);\n        }\n        instancedMesh.count = vertices3D.length;\n        instancedMesh.instanceMatrix.needsUpdate = true;\n        pointsGroup.add(instancedMesh);\n    } else {\n        // no vertices: ensure instanced mesh still removed\n        if (instancedMesh) {\n            // keep instantiatedMesh around for reuse but don't add it to scene\n            instancedMesh.count = 0;\n        }\n    }\n\n    // EDGES (BufferGeometry)\n    clearGroup(edgesGroup);\n    if (settings.showEdges && vertices4D.length >= 2) {\n        const edges = computeEdges4D(vertices4D);\n        cachedEdges = edges;\n        ensureEdgeMesh(edges.length);\n        // fill position buffer\n        const posBuf = edgeMesh.geometry.attributes.position.array;\n        let idx = 0;\n        for (let e = 0; e < edges.length; e++) {\n            const [i, j] = edges[e];\n            const a = vertices3D[i], b = vertices3D[j];\n            if (!a || !b) continue;\n            posBuf[idx++] = a.x; posBuf[idx++] = a.y; posBuf[idx++] = a.z;\n            posBuf[idx++] = b.x; posBuf[idx++] = b.y; posBuf[idx++] = b.z;\n        }\n        // zero out remainder to avoid garbage geometry if buffer larger than used\n        for (; idx < posBuf.length; idx++) posBuf[idx] = 0;\n        edgeMesh.geometry.attributes.position.needsUpdate = true;\n        (edgeMesh.material).color.set(settings.edgeColor);\n        edgeMesh.material.opacity = settings.edgeOpacity;\n        edgeMesh.material.transparent = settings.edgeOpacity < 1.0;\n        edgesGroup.add(edgeMesh);\n    }\n\n    // FACES (Convex hull) â€” try/catch because ConvexGeometry can fail on degenerate sets\n    if (settings.showFaces && vertices3D.length >= 4) {\n        try {\n            // ConvexGeometry expects an array of Vector3\n            const hullGeom = new ConvexGeometry(vertices3D);\n            const mat = new THREE.MeshLambertMaterial({\n                color: settings.faceColor,\n                transparent: settings.faceOpacity < 1.0,\n                opacity: settings.faceOpacity,\n                side: THREE.DoubleSide,\n                depthWrite: false\n            });\n            const mesh = new THREE.Mesh(hullGeom, mat);\n            mesh.renderOrder = 2;\n            facesGroup.add(mesh);\n        } catch (err) {\n            console.warn('ConvexGeometry failed to build hull:', err);\n            // fall back: do nothing, or you could build triangles manually if desired\n        }\n    }\n}\n\n/* convenient clearing helper */\nfunction clearGroup(g) {\n    while (g.children.length) {\n        const obj = g.children[0];\n        g.remove(obj);\n        if (obj.geometry) obj.geometry.dispose();\n        if (obj.material) {\n            if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());\n            else obj.material.dispose();\n        }\n    }\n}\n\n/* -------------------------\n   Cameras + controls\n   ------------------------- */\nlet perspCamera, orthoCamera, currentCamera, controls;\nfunction makeCameras() {\n    const aspect = window.innerWidth / window.innerHeight;\n    perspCamera = new THREE.PerspectiveCamera(60, aspect, 0.01, 1000);\n    perspCamera.position.set(3, 3, 3);\n    perspCamera.lookAt(0, 0, 0);\n\n    const frustum = 4;\n    orthoCamera = new THREE.OrthographicCamera(\n        -frustum * aspect / 2,\n        frustum * aspect / 2,\n        frustum / 2,\n        -frustum / 2,\n        -1000,\n        1000\n    );\n    orthoCamera.position.copy(perspCamera.position);\n    orthoCamera.lookAt(0, 0, 0);\n\n    currentCamera = perspCamera;\n    \n    // CRITICAL: Attach controls to container\n    if (controls) controls.dispose();\n    controls = new OrbitControls(currentCamera, container);\n    controls.enableDamping = true;\n    controls.enabled = true;\n    \n    // Force update pointer events\n    isOverUI = checkIfOverUI();\n    updateCanvasPointerEvents();\n}\nmakeCameras();\n\nwindow.addEventListener('resize', () => {\n    const aspect = window.innerWidth / window.innerHeight;\n    perspCamera.aspect = aspect;\n    perspCamera.updateProjectionMatrix();\n\n    const frustum = 4;\n    orthoCamera.left = -frustum * aspect / 2;\n    orthoCamera.right = frustum * aspect / 2;\n    orthoCamera.top = frustum / 2;\n    orthoCamera.bottom = -frustum / 2;\n    orthoCamera.updateProjectionMatrix();\n\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    \n    // Update pointer events after resize\n    isOverUI = checkIfOverUI();\n    updateCanvasPointerEvents();\n});\n\n/* -------------------------\n   UI wiring\n   ------------------------- */\nfunction setupUI() {\n    const get = id => document.getElementById(id);\n    const showVerts = get('showVerts'), vertColor = get('vertColor'), vertSize = get('vertSize');\n    const showEdges = get('showEdges'), edgeColor = get('edgeColor'), edgeOpacity = get('edgeOpacity');\n    const showFaces = get('showFaces'), faceColor = get('faceColor'), faceOpacity = get('faceOpacity');\n    const rotXY = get('rotXY'), rotXZ = get('rotXZ'), rotYZ = get('rotYZ'), rotXW = get('rotXW'), rotYW = get('rotYW'), rotZW = get('rotZW');\n    const projectionType = get('projectionType');\n    const toggleUIBtn = get('toggleUI'), ui = get('ui'), fullscreenBtn = get('fullscreenBtn');\n    const renderBtn = get('renderBtn'), resMult = get('resMult'), progress = get('progress');\n    const polySelect = get('polytopeSelect');\n\n    if (showVerts) showVerts.addEventListener('change', e => { settings.showVertices = e.target.checked; updateGeometry(); });\n    if (vertColor) vertColor.addEventListener('input', e => { settings.vertexColor = e.target.value; if (instancedMat) instancedMat.color.set(e.target.value); updateGeometry(); });\n    if (vertSize) vertSize.addEventListener('input', e => { settings.vertexSize = parseFloat(e.target.value); updateGeometry(); });\n\n    if (showEdges) showEdges.addEventListener('change', e => { settings.showEdges = e.target.checked; updateGeometry(); });\n    if (edgeColor) edgeColor.addEventListener('input', e => { settings.edgeColor = e.target.value; if (edgeMesh) edgeMesh.material.color.set(e.target.value); updateGeometry(); });\n    if (edgeOpacity) edgeOpacity.addEventListener('input', e => { settings.edgeOpacity = parseFloat(e.target.value); if (edgeMesh) { edgeMesh.material.opacity = settings.edgeOpacity; edgeMesh.material.transparent = settings.edgeOpacity < 1.0; } updateGeometry(); });\n\n    if (showFaces) showFaces.addEventListener('change', e => { settings.showFaces = e.target.checked; updateGeometry(); });\n    if (faceColor) faceColor.addEventListener('input', e => { settings.faceColor = e.target.value; updateGeometry(); });\n    if (faceOpacity) faceOpacity.addEventListener('input', e => { settings.faceOpacity = parseFloat(e.target.value); updateGeometry(); });\n\n    if (rotXY) rotXY.addEventListener('input', e => { settings.rotationXY = parseFloat(e.target.value); updateGeometry(); });\n    if (rotXZ) rotXZ.addEventListener('input', e => { settings.rotationXZ = parseFloat(e.target.value); updateGeometry(); });\n    if (rotYZ) rotYZ.addEventListener('input', e => { settings.rotationYZ = parseFloat(e.target.value); updateGeometry(); });\n    if (rotXW) rotXW.addEventListener('input', e => { settings.rotationXW = parseFloat(e.target.value); updateGeometry(); });\n    if (rotYW) rotYW.addEventListener('input', e => { settings.rotationYW = parseFloat(e.target.value); updateGeometry(); });\n    if (rotZW) rotZW.addEventListener('input', e => { settings.rotationZW = parseFloat(e.target.value); updateGeometry(); });\n\n    if (projectionType) projectionType.addEventListener('change', e => {\n        settings.projectionType = e.target.value;\n        currentCamera = (settings.projectionType === 'parallel') ? orthoCamera : perspCamera;\n        // re-create controls for the new camera\n        if (controls) controls.dispose();\n        controls = new OrbitControls(currentCamera, container);\n        controls.enableDamping = true;\n        boundsToCamera();\n        updateGeometry();\n    });\n\n    if (toggleUIBtn && ui) toggleUIBtn.addEventListener('click', () => {\n        ui.classList.toggle('hidden');\n        toggleUIBtn.textContent = ui.classList.contains('hidden') ? 'Show UI' : 'Hide UI';\n        \n        // Update controls state immediately\n        setTimeout(() => {\n            isOverUI = checkIfOverUI();\n            updateCanvasPointerEvents();\n        }, 100);\n    });\n\n    if (fullscreenBtn && container) fullscreenBtn.addEventListener('click', async () => {\n        try {\n            if (!document.fullscreenElement) {\n                await container.requestFullscreen();\n                // Force resize after fullscreen\n                setTimeout(() => {\n                    window.dispatchEvent(new Event('resize'));\n                    isOverUI = checkIfOverUI();\n                    updateCanvasPointerEvents();\n                }, 300);\n            } else {\n                await document.exitFullscreen();\n                // Force resize after exiting fullscreen\n                setTimeout(() => {\n                    window.dispatchEvent(new Event('resize'));\n                    isOverUI = checkIfOverUI();\n                    updateCanvasPointerEvents();\n                }, 300);\n            }\n        } catch (err) { \n            alert('Fullscreen failed: ' + err.message); \n        }\n    });\n\n    if (renderBtn) renderBtn.addEventListener('click', async () => {\n        progress.textContent = 'Rendering...';\n        try {\n            const mult = Math.max(1, parseInt(resMult.value || '1', 10));\n            const oldPR = renderer.getPixelRatio();\n            renderer.setPixelRatio((window.devicePixelRatio || 1) * mult);\n            renderer.setSize(Math.round(window.innerWidth), Math.round(window.innerHeight), false);\n            await new Promise(requestAnimationFrame);\n            renderer.render(scene, currentCamera);\n            await new Promise(requestAnimationFrame);\n            const dataUrl = renderer.domElement.toDataURL('image/png');\n            renderer.setPixelRatio(oldPR);\n            renderer.setSize(window.innerWidth, window.innerHeight, false);\n\n            const a = document.createElement('a');\n            a.href = dataUrl;\n            a.download = `4d_polytope_${Date.now()}.png`;\n            document.body.appendChild(a);\n            a.click();\n            document.body.removeChild(a);\n\n            progress.textContent = 'Saved!';\n            setTimeout(() => progress.textContent = '', 1500);\n        } catch (err) {\n            console.error(err);\n            progress.textContent = 'Render failed';\n            setTimeout(() => progress.textContent = '', 2000);\n        }\n    });\n\n    if (polySelect) polySelect.addEventListener('change', e => {\n        loadPolytope(e.target.value);\n        boundsToCamera();\n        updateGeometry();\n    });\n}\n\n/* -------------------------\n   Load polytope + camera bounds\n   ------------------------- */\nfunction loadPolytope(name) {\n    switch (name) {\n        case '4-simplex': vertices4D = generate4SimplexVertices(); break;\n        case 'hypercube': vertices4D = generateHypercubeVertices(); break;\n        case '16-cell': vertices4D = generate16CellVertices(); break;\n        case '24-cell': vertices4D = generate24CellVertices(); break;\n        case '120-cell': vertices4D = generate120CellVertices(); break;\n        case '600-cell': vertices4D = generate600CellVertices(); break;\n        default: vertices4D = [];\n    }\n    // reset instance capacity so updateGeometry recreates containers as needed\n    instancedCount = 0;\n}\n\nfunction boundsToCamera() {\n    if (!vertices4D.length) return;\n    // project base shape to 3D without rotations to compute scale\n    const proto3 = vertices4D.map(p => project4Dto3D(p, 3, settings.projectionType));\n    const box = new THREE.Box3().setFromPoints(proto3);\n    const center = box.getCenter(new THREE.Vector3());\n    const size = box.getSize(new THREE.Vector3()).length();\n    const distance = Math.max(2, size * 1.6);\n    perspCamera.position.set(center.x + distance, center.y + distance, center.z + distance);\n    perspCamera.lookAt(center);\n    orthoCamera.position.copy(perspCamera.position);\n    orthoCamera.lookAt(center);\n    if (controls) { \n        controls.target.copy(center); \n        controls.update(); \n    }\n}\n\n/* -------------------------\n   Init sequence\n   ------------------------- */\n// 1. Load polytope\nloadPolytope('24-cell');\n\n// 2. Setup UI\nsetupUI();\n\n// 3. Create cameras\nmakeCameras();\n\n// 4. Set bounds and update\nboundsToCamera();\nupdateGeometry();\n\n// Initial pointer events check\nisOverUI = checkIfOverUI();\nupdateCanvasPointerEvents();\n\n/* -------------------------\n   Animation loop\n   ------------------------- */\nfunction animate() {\n    requestAnimationFrame(animate);\n    \n    // Double-check mouse position for accuracy\n    if (lastMouseX !== undefined && lastMouseY !== undefined) {\n        isOverUI = checkIfOverUI();\n        updateCanvasPointerEvents();\n    }\n    \n    if (controls) controls.update();\n    renderer.render(scene, currentCamera);\n}\nanimate();\n\n/* -------------------------\n   Helpful dev utility: expose small API in console\n   ------------------------- */\nwindow.__poly = {\n    loadPolytope, \n    updateGeometry, \n    boundsToCamera, \n    scene, \n    renderer, \n    camera: () => currentCamera,\n    // Debug functions\n    __isOverUI: () => isOverUI,\n    __checkUI: () => {\n        isOverUI = checkIfOverUI();\n        updateCanvasPointerEvents();\n        return isOverUI;\n    },\n    __debug: () => {\n        console.log({\n            isOverUI,\n            mousePos: [lastMouseX, lastMouseY],\n            uiRect: ui ? ui.getBoundingClientRect() : null,\n            canvasPointerEvents: renderer.domElement.style.pointerEvents\n        });\n    }\n};\n"],"names":["Visible","Deleted","_v1","Vector3","_line3","Line3","_plane","Plane","_closestPoint","_triangle","Triangle","ConvexHull","VertexList","points","i","l","VertexNode","object","node","geometry","attribute","point","faces","ray","target","tNear","tFar","face","vN","vD","t","vertex","start","end","absorbingFace","faceVertices","nextVertex","newFaces","maxDistance","maxFace","distance","min","max","minVertices","maxVertices","j","vertices","extremes","index","v0","v1","v2","v3","Face","activeFaces","eyeVertex","eyeFace","eyePoint","crossEdge","horizon","edge","twinEdge","oppositeFace","horizonEdge","firstSideEdge","previousSideEdge","sideEdge","a","b","c","e0","HalfEdge","e1","e2","head","tail","ConvexGeometry","BufferGeometry","normals","Float32BufferAttribute","container","scene","THREE.Scene","THREE.Color","renderer","THREE.WebGLRenderer","ambient","THREE.AmbientLight","dir","THREE.DirectionalLight","ui","isOverUI","lastMouseX","lastMouseY","updateMousePosition","e","checkIfOverUI","rect","updateCanvasPointerEvents","_a","rotationMatrix4D","angle","m","s","multiplyVecMat4D","v","r0","r1","r2","r3","project4Dto3D","x","y","z","w","perspective","projectionType","THREE.Vector3","denom","factor","normalize4D","len","generate4SimplexVertices","generateHypercubeVertices","vs","vals","generate16CellVertices","generate24CellVertices","verts","si","sj","getAllPermutations","arr","res","p","r","getEvenPermutations","all","out","inv","generate120CellVertices","phi","invPhi","basePoints","perms","perm","mask","generate600CellVertices","val","computeEdges4D","vertices4D","n","edges","distSqList","d2","k","diff","bestIdx","bestRel","lookLimit","rel","threshold","lower","upper","outSet","A","B","key","pointsGroup","THREE.Group","edgesGroup","facesGroup","instancedMesh","instancedCount","instancedGeom","instancedMat","edgeMesh","edgePositions","settings","vertices3D","ensureInstancedMesh","maxCount","THREE.SphereGeometry","THREE.MeshPhongMaterial","THREE.InstancedMesh","THREE.DynamicDrawUsage","ensureEdgeMesh","maxSegments","requiredVerts","geo","THREE.BufferGeometry","THREE.BufferAttribute","mat","THREE.LineBasicMaterial","THREE.LineSegments","updateGeometry","clearGroup","transformed","planes","R","tempMat","THREE.Matrix4","scale","pos","THREE.Quaternion","posBuf","idx","hullGeom","THREE.MeshLambertMaterial","THREE.DoubleSide","mesh","THREE.Mesh","err","g","obj","perspCamera","orthoCamera","currentCamera","controls","makeCameras","aspect","THREE.PerspectiveCamera","frustum","THREE.OrthographicCamera","OrbitControls","setupUI","get","id","showVerts","vertColor","vertSize","showEdges","edgeColor","edgeOpacity","showFaces","faceColor","faceOpacity","rotXY","rotXZ","rotYZ","rotXW","rotYW","rotZW","toggleUIBtn","fullscreenBtn","renderBtn","resMult","progress","polySelect","boundsToCamera","mult","oldPR","dataUrl","loadPolytope","name","proto3","box","THREE.Box3","center","size","animate"],"mappings":"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","x_google_ignoreList":[0,1]}